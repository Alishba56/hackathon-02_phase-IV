# Implementation Plan: Cloud-Native Todo AI Chatbot Deployment

**Branch**: `001-k8s-deployment` | **Date**: 2026-02-08 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-k8s-deployment/spec.md`

## Summary

Transform the existing Phase III Todo AI Chatbot (Next.js frontend + FastAPI backend + Cohere agent) into a production-grade, cloud-native application deployed on local Kubernetes (Minikube) using AI-assisted infrastructure automation. The implementation will containerize both applications with production-ready Dockerfiles, package them in a Helm chart for single-command deployment, and showcase AI-powered DevOps workflows using Gordon (Docker AI), kubectl-ai, and kagent. The deployment will maintain 100% functional parity with Phase III while demonstrating advanced cloud-native maturity through proper observability, secrets management, and resilient orchestration.

## Technical Context

**Infrastructure Platform**: Minikube 1.32+ (Kubernetes 1.28+)
**Container Runtime**: Docker 24.0+ (Docker Desktop 4.53+ Beta for Gordon AI support)
**Orchestration Tools**: Helm 3.12+, kubectl 1.28+
**AI DevOps Tools**: Gordon (Docker AI Agent), kubectl-ai, kagent
**Base Images**:
  - Frontend: node:20-alpine (build), nginx:alpine (runtime)
  - Backend: python:3.11-slim
**Target Platform**: Local Kubernetes cluster (single-node Minikube)
**Project Type**: Infrastructure/DevOps (containerization and orchestration layer)
**Performance Goals**:
  - Pod startup time: < 60 seconds
  - Full deployment: < 5 minutes
  - Application response time: No degradation from Phase III
**Constraints**:
  - Local Minikube only (no cloud clusters)
  - Resource limits: Frontend (256Mi/200m), Backend (512Mi/300m)
  - No changes to Phase III application code
  - External Neon database connectivity required
**Scale/Scope**:
  - 2 containerized services (frontend, backend)
  - 1 Helm chart with 6+ templates
  - 1 Ingress resource with host-based routing
  - Minimal replicas (1-2) for local demo

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Phase IV Principles Compliance

✅ **Principle XVII - AI-Powered Infrastructure Automation**: Plan prioritizes Gordon for Dockerfiles, kubectl-ai for K8s resources, kagent for analysis. Manual commands documented as fallback only.

✅ **Principle XVIII - Container-First Application Design**: Multi-stage Dockerfiles planned for both services with optimization, layer caching, and minimal base images.

✅ **Principle XIX - Helm-Based Deployment Management**: All Kubernetes resources managed through Helm chart with proper templating and values.yaml configuration.

✅ **Principle XX - Local Kubernetes Development Parity**: Minikube deployment mirrors production patterns with Ingress, proper service discovery, and identical configuration approach.

✅ **Principle XXI - Secrets and Configuration Management**: All sensitive data via Kubernetes Secrets, non-sensitive via ConfigMaps, no hardcoded values.

✅ **Principle XXII - Observability and Health Monitoring**: Readiness/liveness probes, structured logging, resource requests/limits defined for all containers.

✅ **Principle XXIII - Zero-Downtime Deployment Strategy**: Rolling update strategy with readiness checks, graceful shutdown handling.

✅ **Principle XXIV - Infrastructure as Code Traceability**: All infrastructure artifacts traceable to @specs/infra/ specifications.

### Phase IV Constraints Compliance

✅ **Deployment Target Lock**: Minikube only, no cloud clusters
✅ **AI Tool Priority**: Gordon/kubectl-ai/kagent prioritized with documented fallbacks
✅ **Helm Chart Generation**: Charts generated by Claude Code, no manual helm create
✅ **Database Strategy**: External Neon preserved, no application code changes
✅ **No Cloud Resources**: Pure local infrastructure
✅ **Code Preservation**: Infrastructure layer only, no Phase III code modifications
✅ **Environment Injection**: Secrets/ConfigMaps for all configuration
✅ **Ingress Requirement**: Host-based routing via Minikube ingress addon

**Gate Status**: ✅ PASSED - All Phase IV principles and constraints satisfied

## Project Structure

### Documentation (this feature)

```text
specs/001-k8s-deployment/
├── spec.md                    # Feature specification (completed)
├── plan.md                    # This file (in progress)
├── research.md                # Phase 0: Technology research and decisions
├── architecture.md            # Phase 1: Infrastructure architecture design
├── helm-chart-design.md       # Phase 1: Helm chart structure and templates
├── ai-devops-workflows.md     # Phase 1: AI tool integration patterns
├── quickstart.md              # Phase 1: Deployment quickstart guide
├── checklists/
│   └── requirements.md        # Specification quality checklist (completed)
└── tasks.md                   # Phase 2: Implementation tasks (created by /sp.tasks)
```

### Infrastructure Code (repository root)

```text
infra/
├── docker/
│   ├── frontend/
│   │   ├── Dockerfile              # Multi-stage Next.js build
│   │   ├── .dockerignore           # Build exclusions
│   │   └── nginx.conf              # Production nginx config
│   └── backend/
│       ├── Dockerfile              # FastAPI + uvicorn container
│       └── .dockerignore           # Python build exclusions
│
├── helm/
│   └── todo-app/
│       ├── Chart.yaml              # Helm chart metadata
│       ├── values.yaml             # Configurable parameters
│       ├── values-dev.yaml         # Development overrides
│       ├── templates/
│       │   ├── _helpers.tpl        # Template helpers
│       │   ├── deployment-frontend.yaml
│       │   ├── deployment-backend.yaml
│       │   ├── service-frontend.yaml
│       │   ├── service-backend.yaml
│       │   ├── ingress.yaml
│       │   ├── secrets.yaml
│       │   └── configmap.yaml
│       └── .helmignore
│
├── k8s/
│   └── minikube/
│       ├── setup.sh                # Minikube initialization script
│       ├── setup.ps1               # Windows PowerShell version
│       └── teardown.sh             # Cleanup script
│
└── scripts/
    ├── build-images.sh             # Docker image build automation
    ├── load-images.sh              # Load images to Minikube
    ├── deploy.sh                   # Helm install wrapper
    └── demo.sh                     # AI tool demo script

docs/
└── deployment/
    ├── MINIKUBE_SETUP.md           # Minikube installation guide
    ├── AI_TOOLS_GUIDE.md           # Gordon/kubectl-ai/kagent usage
    └── TROUBLESHOOTING.md          # Common issues and solutions
```

**Structure Decision**: Infrastructure-focused layout with clear separation between Docker artifacts (infra/docker/), Helm charts (infra/helm/), Kubernetes configs (infra/k8s/), and automation scripts (infra/scripts/). Documentation organized under specs/001-k8s-deployment/ for design artifacts and docs/deployment/ for operational guides. Existing frontend/ and backend/ directories remain untouched per Phase IV constraints.

## Complexity Tracking

> **No violations requiring justification** - All Phase IV principles and constraints are satisfied without exceptions.

## Phase 0: Research & Technology Decisions

### Research Areas

1. **Next.js Containerization Best Practices**
   - Multi-stage build patterns for Next.js 16+ App Router
   - Standalone output mode for minimal production images
   - Static asset optimization and caching strategies
   - Environment variable injection at runtime vs build time

2. **FastAPI Production Deployment**
   - Uvicorn worker configuration for containerized environments
   - Python dependency management (pip vs poetry in containers)
   - Health check endpoint patterns
   - Graceful shutdown handling for database connections

3. **Helm Chart Design Patterns**
   - Template organization for multi-service applications
   - Values.yaml structure for environment-specific configuration
   - Secret management patterns (external secrets vs inline)
   - Ingress configuration for path-based routing

4. **Minikube Ingress Configuration**
   - Nginx ingress controller setup and configuration
   - Host-based routing with local DNS (todo.local)
   - Path rewriting for backend API routes
   - TLS termination (optional for local demo)

5. **AI Tool Integration Patterns**
   - Gordon Docker AI command syntax and capabilities
   - kubectl-ai natural language command patterns
   - kagent cluster analysis and debugging workflows
   - Fallback strategies when AI tools unavailable

6. **Kubernetes Resource Optimization**
   - Resource requests/limits for local Minikube constraints
   - Readiness vs liveness probe configuration
   - Rolling update strategies for zero-downtime
   - Pod disruption budgets for resilience

### Research Output

**Artifact**: `research.md` containing:
- Technology choices with rationale
- Alternatives considered and rejected
- Best practices for each component
- Risk mitigation strategies
- AI tool capabilities and limitations

## Phase 1: Design & Architecture

### Architecture Design

**Artifact**: `architecture.md`

**Contents**:
1. **System Architecture Diagram**
   - Minikube cluster topology
   - Pod placement and networking
   - Ingress routing flow
   - External dependencies (Neon DB, Cohere API)

2. **Container Architecture**
   - Frontend container design (build + runtime stages)
   - Backend container design (dependencies + application)
   - Image tagging and versioning strategy
   - Registry strategy (local Minikube image cache)

3. **Kubernetes Resource Architecture**
   - Deployment specifications (replicas, update strategy)
   - Service discovery and internal networking
   - Ingress routing rules and host mapping
   - Secret and ConfigMap organization

4. **Network Architecture**
   - Pod-to-pod communication
   - Service-to-service routing
   - Ingress-to-service mapping
   - External connectivity (database, APIs)

5. **Observability Architecture**
   - Logging strategy (stdout/stderr to kubectl logs)
   - Health check endpoints and probe configuration
   - Resource monitoring approach
   - Debugging workflows with AI tools

### Helm Chart Design

**Artifact**: `helm-chart-design.md`

**Contents**:
1. **Chart Structure**
   - Chart.yaml metadata and versioning
   - values.yaml parameter organization
   - Template hierarchy and dependencies

2. **Template Specifications**
   - Deployment templates (frontend, backend)
   - Service templates (ClusterIP configuration)
   - Ingress template (host and path routing)
   - Secret template (base64 encoding patterns)
   - ConfigMap template (non-sensitive config)

3. **Values Configuration**
   - Image repository and tag configuration
   - Replica count and resource limits
   - Environment-specific overrides
   - Secret value injection patterns

4. **Helm Hooks and Lifecycle**
   - Pre-install validation hooks
   - Post-install verification
   - Upgrade and rollback strategies

### AI DevOps Workflows

**Artifact**: `ai-devops-workflows.md`

**Contents**:
1. **Gordon (Docker AI) Workflows**
   - Dockerfile generation commands
   - Image optimization suggestions
   - Build troubleshooting with AI assistance
   - Fallback to manual Dockerfile creation

2. **kubectl-ai Workflows**
   - Deployment generation from natural language
   - Scaling operations with AI commands
   - Resource analysis and optimization
   - Debugging pod failures with AI assistance

3. **kagent Workflows**
   - Cluster health analysis commands
   - Resource utilization monitoring
   - Log analysis and pattern detection
   - Performance optimization suggestions

4. **Integrated Demo Script**
   - Step-by-step AI tool showcase
   - Natural language command examples
   - Expected outputs and validations
   - Fallback procedures for tool failures

### Deployment Quickstart

**Artifact**: `quickstart.md`

**Contents**:
1. **Prerequisites**
   - Required tools and versions
   - System resource requirements
   - Account setup (Neon, Cohere)

2. **One-Command Deployment**
   ```bash
   # Setup Minikube
   ./infra/k8s/minikube/setup.sh

   # Build and load images
   ./infra/scripts/build-images.sh
   ./infra/scripts/load-images.sh

   # Deploy with Helm
   helm install todo-app ./infra/helm/todo-app \
     --set secrets.betterAuthSecret=$BETTER_AUTH_SECRET \
     --set secrets.cohereApiKey=$COHERE_API_KEY \
     --set secrets.databaseUrl=$DATABASE_URL

   # Verify deployment
   kubectl get pods,svc,ingress

   # Access application
   open http://todo.local
   ```

3. **Verification Steps**
   - Pod health checks
   - Service connectivity tests
   - Ingress routing validation
   - Application functionality tests

4. **Troubleshooting**
   - Common issues and solutions
   - Log access commands
   - AI tool debugging workflows

### Data Model

**Not Applicable**: This feature is infrastructure-only. No new data entities are introduced. Existing Phase III data model (users, tasks, conversations, messages) remains unchanged.

### API Contracts

**Not Applicable**: This feature is infrastructure-only. No API changes are introduced. Existing Phase III API contracts remain unchanged. All endpoints maintain identical behavior when deployed to Kubernetes.

## Phase 2: Implementation Planning

**Note**: Detailed task breakdown will be generated by `/sp.tasks` command after this planning phase completes.

### Implementation Phases

#### Phase 2.1: Foundation - Containerization
- Generate/create production-ready Dockerfiles using Gordon or Claude Code
- Implement multi-stage builds for optimal image size
- Configure health check endpoints in applications
- Build and test images locally
- Document image build process and optimization decisions

#### Phase 2.2: Minikube Setup
- Create Minikube initialization scripts (Bash + PowerShell)
- Configure required addons (ingress, metrics-server)
- Set up host file mapping for todo.local
- Validate cluster readiness
- Document Minikube configuration and troubleshooting

#### Phase 2.3: Helm Chart Generation
- Generate Helm chart structure using kubectl-ai or Claude Code
- Create deployment templates with probes and resource limits
- Configure service templates for internal networking
- Implement ingress template with host-based routing
- Design values.yaml with all configurable parameters
- Document Helm chart usage and customization

#### Phase 2.4: Secrets & Configuration
- Create Kubernetes Secret templates for sensitive data
- Implement ConfigMap for non-sensitive configuration
- Document secret creation and injection process
- Validate environment variable propagation to pods

#### Phase 2.5: Deployment & Verification
- Implement Helm install automation scripts
- Deploy application to Minikube
- Verify pod health and readiness
- Test service connectivity and ingress routing
- Validate full application functionality in Kubernetes
- Document deployment process and verification steps

#### Phase 2.6: AI DevOps Showcase
- Document Gordon containerization workflows
- Create kubectl-ai operation examples (scale, analyze, debug)
- Implement kagent health analysis workflows
- Build comprehensive demo script for judges
- Record AI tool interactions in PHRs

#### Phase 2.7: Polish & Documentation
- Add comprehensive README with deployment instructions
- Create troubleshooting guide for common issues
- Document AI tool setup and usage
- Prepare demo presentation materials
- Final end-to-end validation against success criteria

## Key Architectural Decisions

### Decision 1: Containerization Strategy

**Decision**: Use Gordon (Docker AI Agent) for Dockerfile generation when available, with Claude Code-generated fallback Dockerfiles maintained in repository.

**Rationale**:
- Demonstrates cutting-edge AI-augmented DevOps (key Phase IV differentiator)
- Gordon can optimize Dockerfiles based on best practices
- Fallback ensures deployment works without Gordon dependency
- Both approaches documented for hackathon judges

**Alternatives Considered**:
- Manual Dockerfile creation: Rejected (doesn't showcase AI capabilities)
- Gordon-only approach: Rejected (creates hard dependency on beta feature)

**Implementation**: Maintain both Gordon commands and pre-generated Dockerfiles in repository. Demo script shows Gordon workflow first, falls back to pre-generated files if unavailable.

### Decision 2: Database Strategy

**Decision**: Keep external Neon PostgreSQL database from Phase III, no local database pod.

**Rationale**:
- Maintains consistency with Phase III (no data migration needed)
- Simplifies Kubernetes deployment (fewer moving parts)
- Demonstrates hybrid architecture (local compute + cloud database)
- Reduces Minikube resource requirements

**Alternatives Considered**:
- Local PostgreSQL pod: Rejected (adds complexity, requires data migration, increases resource usage)
- StatefulSet with persistent volumes: Rejected (overkill for demo, complicates deployment)

**Implementation**: Database connection string injected via Kubernetes Secret, identical to Phase III .env configuration.

### Decision 3: Helm Chart Complexity

**Decision**: Basic Helm chart with deployments, services, ingress, secrets, and health probes. Include comments for future enhancements (HPA, network policies).

**Rationale**:
- Sufficient for local Minikube demo
- Shows production-ready patterns (probes, resource limits, rolling updates)
- Keeps deployment simple and fast
- Comments demonstrate awareness of advanced features

**Alternatives Considered**:
- Minimal chart (no probes/limits): Rejected (doesn't demonstrate production readiness)
- Advanced chart (HPA, network policies, PDB): Rejected (overkill for local single-node cluster)

**Implementation**: Comprehensive but focused chart with inline documentation for future enhancements.

### Decision 4: Ingress Configuration

**Decision**: Use Minikube nginx ingress addon with host-based routing (todo.local) and /etc/hosts mapping.

**Rationale**:
- Standard Kubernetes ingress pattern
- Demonstrates proper external access configuration
- Works reliably on local Minikube
- Mirrors production ingress setup

**Alternatives Considered**:
- NodePort services: Rejected (not production-like, requires port management)
- Port forwarding: Rejected (manual, not persistent, doesn't showcase ingress)
- LoadBalancer with minikube tunnel: Rejected (adds complexity, tunnel management)

**Implementation**: Ingress resource with host: todo.local, path-based routing (/ → frontend, /api → backend), documented host file setup.

### Decision 5: Resource Limits

**Decision**: Conservative resource requests/limits optimized for local Minikube (Frontend: 256Mi/200m, Backend: 512Mi/300m).

**Rationale**:
- Ensures deployment works on typical developer machines
- Prevents resource exhaustion on single-node cluster
- Still demonstrates proper resource management
- Documented as "local demo values" with production recommendations

**Alternatives Considered**:
- No limits: Rejected (doesn't show production best practices)
- Production-scale limits: Rejected (may not fit in local Minikube)

**Implementation**: Conservative limits in values.yaml with comments explaining production scaling considerations.

### Decision 6: AI Tool Integration

**Decision**: Layer AI tools by function - Gordon for containerization, kubectl-ai for resource generation/operations, kagent for analysis/debugging.

**Rationale**:
- Each tool showcases different AI capabilities
- Demonstrates comprehensive AI-augmented workflow
- Provides multiple impressive demo moments
- Shows practical AI tool usage patterns

**Alternatives Considered**:
- Single tool focus: Rejected (misses opportunity to showcase breadth)
- All tools for all tasks: Rejected (redundant, confusing)

**Implementation**: Structured demo script with clear tool responsibilities, documented workflows for each tool, fallback procedures.

## Risk Analysis & Mitigation

### Risk 1: Gordon Unavailable or Non-Functional
**Probability**: Medium | **Impact**: Medium
**Mitigation**:
- Maintain pre-generated production-ready Dockerfiles in repository
- Document both Gordon and manual workflows
- Test fallback path during development
- Demo script includes fallback procedure

### Risk 2: Minikube Resource Constraints
**Probability**: Medium | **Impact**: High
**Mitigation**:
- Conservative resource requests/limits
- Document minimum system requirements (4 CPU, 8GB RAM)
- Provide troubleshooting guide for resource issues
- Test on minimum-spec machine

### Risk 3: Ingress Configuration Issues
**Probability**: Low | **Impact**: Medium
**Mitigation**:
- Detailed ingress setup documentation
- Automated host file configuration in setup script
- Troubleshooting guide for common ingress issues
- Fallback to port-forward for demo if needed

### Risk 4: Database Connectivity from Minikube
**Probability**: Low | **Impact**: High
**Mitigation**:
- Test Neon connectivity from Minikube during development
- Document network configuration requirements
- Provide local PostgreSQL pod as emergency fallback
- Include connectivity test in deployment verification

### Risk 5: AI Tools Generate Incorrect Configurations
**Probability**: Medium | **Impact**: Medium
**Mitigation**:
- Validate all AI-generated configs before deployment
- Maintain tested baseline configurations
- Document manual override procedures
- Include validation steps in demo script

## Success Criteria Mapping

### P1: Complete Application Deployment (Foundational)

| Success Criterion | Implementation Approach | Validation Method |
|-------------------|------------------------|-------------------|
| SC-001: Deployment < 5 min | Optimized images, pre-pulled base images, efficient Helm chart | Time helm install command |
| SC-002: Pods ready < 2 min | Fast startup, health checks, resource pre-allocation | kubectl wait --for=condition=ready |
| SC-003: Ingress accessible < 30s | Pre-configured ingress, DNS ready | curl http://todo.local |
| SC-004: 100% Phase III parity | No application code changes, identical API behavior | End-to-end functional tests |
| SC-005: Automatic recovery | Kubernetes self-healing, proper probes | kubectl delete pod, verify recovery |

### P2: AI-Assisted Operations (Differentiator)

| Success Criterion | Implementation Approach | Validation Method |
|-------------------|------------------------|-------------------|
| SC-006: 3+ AI tool demos | Gordon containerization, kubectl-ai scale/debug, kagent analysis | Demo script execution |
| SC-011: Zero manual YAML | Helm values.yaml only, AI-generated templates | Code review, demo walkthrough |

### P3: Observability (Production Readiness)

| Success Criterion | Implementation Approach | Validation Method |
|-------------------|------------------------|-------------------|
| SC-007: Accessible logs | Structured logging, kubectl logs integration | kubectl logs <pod> |
| SC-008: Resource limits respected | Defined requests/limits, monitoring | kubectl top pods |
| SC-009: Startup < 60s | Optimized images, efficient initialization | Pod creation timestamp analysis |
| SC-012: Deploy in < 15 min | Comprehensive quickstart guide, automation scripts | New user testing |

## Next Steps

1. **Complete Phase 0**: Generate `research.md` with technology research and best practices
2. **Complete Phase 1**: Generate architecture, Helm chart design, AI workflows, and quickstart documentation
3. **Run `/sp.tasks`**: Generate detailed implementation task breakdown
4. **Execute Implementation**: Follow task sequence with AI tool integration
5. **Validate**: Test against all success criteria
6. **Document**: Create PHRs for all implementation steps

## Appendix: Technology Stack

### Infrastructure Tools
- **Minikube**: 1.32+ (Kubernetes 1.28+)
- **Docker**: 24.0+ (Docker Desktop 4.53+ Beta for Gordon)
- **Helm**: 3.12+
- **kubectl**: 1.28+

### AI DevOps Tools
- **Gordon**: Docker AI Agent (Docker Desktop Beta feature)
- **kubectl-ai**: Natural language Kubernetes operations
- **kagent**: Cluster health analysis and debugging

### Container Base Images
- **Frontend Build**: node:20-alpine
- **Frontend Runtime**: nginx:alpine
- **Backend**: python:3.11-slim

### Kubernetes Resources
- **Deployments**: 2 (frontend, backend)
- **Services**: 2 (ClusterIP)
- **Ingress**: 1 (nginx)
- **Secrets**: 1 (auth, API keys, database)
- **ConfigMaps**: 1 (non-sensitive config)

### External Dependencies (Unchanged from Phase III)
- **Database**: Neon Serverless PostgreSQL
- **AI Service**: Cohere API (command-r-plus)
- **Authentication**: Better Auth (JWT)
